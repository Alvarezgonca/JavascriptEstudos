<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explicação Detalhada de JavaScript</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        h1, h2 {
            color: #333;
        }
        h1 {
            text-align: center;
        }
        .content {
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        pre {
            background-color: #282c34;
            color: #61dafb;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
        }
        code {
            color: #56b6c2;
        }
        p {
            color: #555;
        }
        footer {
            text-align: center;
            margin-top: 40px;
            color: #777;
        }
    </style>
</head>
<body>
    <h1>Explicação Detalhada de JavaScript</h1>
    
    <div class="content">
        <h2>Exemplo de Função e Escopo de Variáveis</h2>
        <p>Funções podem acessar variáveis que estão no escopo onde foram criadas. Veja o exemplo abaixo:</p>
        <pre><code>
// Exemplo 1
function exemplo() {
    let variavelString = "Olá, sou uma string";
    function variavelDiferente() {
        let outraVariavel = "Sou outra variável";
        console.log(variavelString);
        console.log(outraVariavel);
    }
    variavelDiferente();
}
exemplo();
        </code></pre>
    </div>

    <div class="content">
        <h2>Exemplo de Escopo com var, let e const</h2>
        <p>O comportamento de <code>var</code>, <code>let</code> e <code>const</code> no escopo de blocos é diferente:</p>
        <pre><code>
// Exemplo 2
function exemplo() {
    var x = 1;
    let y = 2;
    const z = 3;
    if (true) {
        var x = 10; // var é redeclarada e afeta o escopo global da função
        let y = 20; // let é limitada ao bloco
        // z = 30;  // Erro: const não pode ser reatribuída
    }
    console.log(x); // 10
    console.log(y); // 2
    console.log(z); // 3
}
exemplo();
        </code></pre>
    </div>

    <div class="content">
        <h2>Closures</h2>
        <p>Um closure é uma função que "se lembra" do ambiente léxico em que foi criada, mesmo após ser executada:</p>
        <pre><code>
// Exemplo 3
function criarContador() {
    let contador = 0;
    return function() {
        return contador++;
    }
}
const meuContador = criarContador();
console.log(meuContador()); // 0
console.log(meuContador()); // 1
console.log(meuContador()); // 2
        </code></pre>
    </div>

    <div class="content">
        <h2>Uso do <code>this</code> em JavaScript</h2>
        <p>O <code>this</code> faz referência ao objeto atual no qual o código está sendo executado.</p>
        
        <h3>1. Função como Método de Objeto</h3>
        <pre><code>
// Exemplo 4
const pessoa = {
    nome: "Joãozinho",
    idade: 25,
    saudar: function() {
        console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos.`);
    }
}
pessoa.saudar();
        </code></pre>

        <h3>2. Referência ao Objeto Global (Window)</h3>
        <pre><code>
// Exemplo 5
function minhaFuncao() {
    console.log(this); // Em navegadores, this faz referência ao objeto global window
}
minhaFuncao();
        </code></pre>

        <h3>3. Funções com <code>call()</code> e <code>apply()</code></h3>
        <pre><code>
// Exemplo 6
function nossaFuncao(arg1, arg2) {
    console.log(this, arg1, arg2);
}
const obj = { nome: "Joãozinho" };
nossaFuncao.call(obj, 'Olá', 'Mundo'); // this referenciando obj
        </code></pre>
    </div>

    <div class="content">
        <h2>High Order Functions</h2>
        <p>São funções que recebem ou retornam outras funções, como as bases da programação funcional:</p>
        <pre><code>
// Exemplo 7
function mapear(array, funcao) {
    const resultados = [];
    for (let i = 0; i < array.length; i++) {
        resultados.push(funcao(array[i]));
    }
    return resultados;
}
const numeros = [1, 2, 3, 4];
const dobro = numeros.map(numero => numero * 2);
console.log(dobro); // [2, 4, 6, 8]
        </code></pre>
    </div>

    <div class="content">
        <h2>Imutabilidade e Spread Operator</h2>
        <p>Imutabilidade significa que, em vez de modificar um valor existente, criamos novos valores. O spread operator ajuda nisso:</p>
        <pre><code>
// Exemplo 8
const pessoa = { nome: "Joãozinho", idade: 30 };
const novaPessoa = { ...pessoa, idade: 31 };
console.log(pessoa); // {nome: "Joãozinho", idade: 30}
console.log(novaPessoa); // {nome: "Joãozinho", idade: 31}

const fruta1 = ["Banana", "Maçã", "Uva"];
const fruta2 = [...fruta1, "Laranja"];
console.log(fruta1); // ["Banana", "Maçã", "Uva"]
console.log(fruta2); // ["Banana", "Maçã", "Uva", "Laranja"]
        </code></pre>
    </div>

    <footer>
        <p>Estudo sobre JavaScript &copy; 2024</p>
    </footer>
</body>
</html>
